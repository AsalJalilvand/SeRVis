import pandas as pd
import pickle
import plotly.express as px
import dash
from dash.dependencies import Output, Input, State
import dash_table
import dash_core_components as dcc
import dash_html_components as html
import dash_bootstrap_components as dbc
from pattern_mining.post_processing.rule_dag import RuleDAG
from pattern_mining.post_processing.itemset_graph import ItemsetGraph
from pattern_mining.pre_processing.dictionary import AirportMapping

'''
Not tested with cases where we have multiple matrices generated by RuleDAG
app.callback might need modifications
'''

ce_mapping = AirportMapping()

# Data
labels_df = pd.read_pickle("pattern_mining/data/HIAA_anonymized/labeled_sequences.pkl") # sequences removed, only ids (NDA)
delta_labels_df = pd.read_pickle("pattern_mining/data/HIAA_anonymized/labeled_deltas.pkl") # deltas removed, only ids (NDA)
flat_flight_tid = pd.read_csv("pattern_mining/data/HIAA_anonymized/turnaround_arr_dep_flights.csv")
weather_tid_df = pd.read_csv("pattern_mining/data/HIAA_anonymized/tid_weather.csv")
performance_detail_df = pd.read_csv("pattern_mining/data/HIAA_anonymized/performance_detail.csv")
delta_performance_detail_df = pd.read_csv("pattern_mining/data/HIAA_anonymized/delta_performance_detail.csv")


def get_sunburst(flight_df: pd.DataFrame) -> px.sunburst:
    '''
    returns sunburst of flight categories from flight dataframe
    '''
    tmp = flight_df.copy()
    tmp['count'] = 1
    sun_fig = px.sunburst(tmp, path=['Stand', 'Performance', 'AL', 'A/C Type'], values='count',
                          template='simple_white', height=200, maxdepth=3, title='<b>Category Distribution</b>')
    sun_fig.update_traces(textinfo="label+percent entry")
    sun_fig.update_layout(margin=dict(l=0, r=0, b=0, t=15, pad=0), titlefont={'size': 11})
    return sun_fig


def get_heatmap(flight_df: pd.DataFrame) -> px.imshow:
    '''
    returns calendar heatmap of flight dates from flight dataframe
    '''
    heatmap = pd.crosstab(flight_df.daytime, flight_df.weekday)
    heatmap_fig = px.imshow(heatmap,
                            labels=dict(x="Day of Week", y="Time of Day", color="Count"),
                            x=heatmap.columns,
                            y=heatmap.index,
                            color_continuous_scale='greens', height=170, title='<b>Pattern Temporal Distribution</b>')
    heatmap_fig.update_layout(margin=dict(l=0, r=0, b=0, t=15, pad=0), font={'size': 11}, titlefont={'size': 11})
    return heatmap_fig


def get_weater_pc(rule_tids: list, tid_weather: pd.DataFrame) -> px.parallel_coordinates:
    '''
    :param rule_tids: turnaround ids associated with rules
    :param tid_weather: weather dataframe with weather info and turnaround ids
    :return: parallel coordinates of median weather condition
    '''
    data = []
    for tids in rule_tids:
        data.append(tid_weather[tid_weather['Turnaround ID'].isin(tids)].median().to_dict())
    fig = px.parallel_coordinates(data, title='<b>Median Weather Condition per Pattern</b>', height=200)
    fig.update_layout(margin=dict(l=20, r=20, b=20, pad=0, t=80), font=dict(size=10), titlefont={'size': 11})
    return fig


def get_performance_table(performance_df: pd.DataFrame, rule_items: list,anonymous=False) -> dash_table:
    '''
    :param performance_df: dataframe of turnaround/delta statistical details
    :param rule_items: statistical columns to include in detail table
    :return: turnaround/delta detail table
    '''
    if anonymous:
        columns = ["Turnaround ID", "AL", "A/C Type", "Stand", "weekday", "daytime"]
    else:
        columns = ["Turnaround ID", "DATE", "AL", "A/C Type", "Stand", "Arr Sch Time",
               "Arr Act Time",
               "Dep Sch Time", "Dep Act Time", "weekday", "daytime", "stat_group_id"]
        if all(elem in list(performance_df.columns) for elem in ['duration', 'Performance_x']):
            columns.extend(['duration', 'Performance_x'])
        else:
            columns.append('Performance')
        for item_code in rule_items:
            parent_code = ce_mapping.code_to_event[str(item_code)]['parent']
            parent_name = ce_mapping.code_to_event[str(parent_code)]['event']
            columns.extend([parent_name, parent_name + " 0.4 quantile", parent_name + " 0.6 quantile"])

    return dash_table.DataTable(
        id='p_table', columns=[{"name": i, "id": i} for i in columns],
        data=performance_df[columns].to_dict('records'), style_cell=dict(textAlign='left'),
        page_action="native", page_current=0, page_size=15, sort_action="native", sort_mode="multi",
        style_header=dict(backgroundColor="lightgrey"), style_table={'width': '100%', 'overflowX': 'auto'})


# Rule Parsing and Matrix generation
with open('pattern_mining/data/HIAA_anonymized/rules.pkl', 'rb') as f:
    rules = pickle.load(f)
rd = RuleDAG(tagged=False)
matrices, full_graph = rd.create_matrices(rules, cluster=False, id_as_column=True)

# Frequent itemset parsing and lattice generation
with open('pattern_mining/data/HIAA_anonymized/fis.pkl', 'rb') as f:
    freqitemsets = pickle.load(f)
lattice_fig = ItemsetGraph().generate_plotly_figure(freqitemsets)

# Get list of tids per rule, used for generating parallel coordinates for weather, one line per rule
# which is the median of weather condition of sequences of each rule
tids_per_rule = [rule.seq_ids for rule in rules]
tids_per_fis = [fis.seq_ids for fis in freqitemsets]

# Create rule table and legend, with sup and conf as columns
table_legend = ["#Records: " + str(flat_flight_tid.shape[0]),
                html.Br(), html.Br(),
                "Antecedent",
                html.Ul(children=[html.Li("Early", style={'color': 'rgba(140,187,255, 0.8)'}),
                                  html.Li("On-time", style={'color': 'rgba(25,119,255, 0.8)'}),
                                  html.Li("Delayed", style={'color': 'rgba(9,44,93, 0.8)'})]),
                "Consequent",
                html.Ul(children=[html.Li("Early", style={'color': 'rgba(255,203,183, 0.8)'}),
                                  html.Li("On-time", style={'color': 'rgba(255,125,77, 0.8)'}),
                                  html.Li("Delayed", style={'color': 'rgba(255,69,0, 0.8)'})])
                ]
rule_table = [
    dash_table.DataTable(
        id='table',
        columns=[{"name": i, "id": i}
                 for i in m.columns],
        data=m.to_dict('records'),
        sort_action="native",
        sort_mode="multi",
        row_selectable='multi',
        selected_rows=[],
        tooltip={i: {'value': i, 'use_with': 'both'} for i in m.columns},
        style_data={
            'font_size': '13px',
            'text-align': 'center'
        },
        style_header={
            # 'overflow': 'hidden',
            # 'textOverflow': 'ellipsis',
            'font_size': '14px',
            'whiteSpace': 'normal',
            'height': 'auto',
            'text-align': 'left',
            # 'maxWidth': '0px'
            'minWidth': '45px', 'width': '45px', 'maxWidth': '45px',

        },
        style_table={
            'height': 600,
            'overflowX': 'auto',
            'overflowY': 'auto'},
        style_data_conditional=[
                                   {'if': {'filter_query': '{{{0}}} = "A.E."'.format(c), 'column_id': c},
                                    'backgroundColor': 'rgba(140,187,255, 0.8)',
                                    } for c in m.columns
                               ] + [
                                   {'if': {'filter_query': '{{{0}}} = "A.O."'.format(c), 'column_id': c},
                                    'backgroundColor': 'rgba(25,119,255, 0.8)',
                                    } for c in m.columns]
                               + [
                                   {'if': {'filter_query': '{{{0}}} = "A.D."'.format(c), 'column_id': c},
                                    'backgroundColor': 'rgba(9,44,93, 0.8)',
                                    } for c in m.columns
                               ]
                               + [
                                   {'if': {'filter_query': '{{{0}}} = "C.D."'.format(c), 'column_id': c},
                                    'backgroundColor': 'rgba(255,69,0, 0.8)',
                                    } for c in m.columns
                               ]
                               + [
                                   {'if': {'filter_query': '{{{0}}} = "C.O."'.format(c), 'column_id': c},
                                    'backgroundColor': 'rgba(255,125,77, 0.8)',
                                    } for c in m.columns
                               ]
                               + [
                                   {'if': {'filter_query': '{{{0}}} = "C.E."'.format(c), 'column_id': c},
                                    'backgroundColor': 'rgba(255,203,183, 0.8)',
                                    } for c in m.columns
                               ]
                               + [
                                   {'if': {'column_id': 'rid', },
                                    'display': 'None', }]
                               + [
                                   {'if': {'column_id': 'group', },
                                    'display': 'None', }]
                               + [
                                   {'if': {'column_id': 'level', },
                                    'display': 'None', }],
        style_header_conditional=[
                                     {'if': {'column_id': 'rid', },
                                      'display': 'None', }]
                                 + [
                                     {'if': {'column_id': 'group', },
                                      'display': 'None', }]
                                 + [
                                     {'if': {'column_id': 'level', },
                                      'display': 'None', }],
    )
    for m in matrices]

# Simple Dashboard
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])
app.layout = dbc.Container([
    html.H6(children='HIAA Pattern Mining Project'),
    html.Hr(),
    dbc.Row([
        dbc.Col(table_legend, width=1, style={'font-size': 'small', 'font-weight': 'bold'}),
        dbc.Col(dcc.Tabs(id='tabs',
                         children=[
                             dcc.Tab(label='Sequential Rules', children=rule_table),
                             dbc.Tab(label='Frequent Itemsets', children=[dcc.Graph(id='lattice', figure=lattice_fig)])
                         ]
                         ), width=8),
        dbc.Col(
            [dcc.Graph(id='sunburst', figure=get_sunburst(flat_flight_tid)),
             html.Hr(),
             dcc.Graph(id='heatmap', figure=get_heatmap(flat_flight_tid)),
             html.Hr(),
             dcc.Graph(id='parallel', figure=get_weater_pc(tids_per_rule, weather_tid_df))]
            , width=3)
    ]),
    html.Br(),
    dbc.Row([
        dbc.Col([dbc.Button('Performance Breakdown', id='brkdwn_btn', n_clicks=0, outline=True, color="info",
                            className="mr-1", size="sm")])
    ]),
    html.Br(),
    dbc.Row([dbc.Col([html.Div([], id='performance_brkdwn')], width=12)])
], fluid=True)


@app.callback(
    [Output('sunburst', 'figure'), Output('heatmap', 'figure'), Output('parallel', 'figure'),
     Output('performance_brkdwn', 'style'), Output("performance_brkdwn", "children")],
    [Input('table', "derived_virtual_data"), Input('table', "derived_virtual_selected_rows"),
     Input('brkdwn_btn', 'n_clicks'), Input('lattice', 'clickData'), Input('tabs', 'value')],
    State("performance_brkdwn", "children"))
def update_figures(rows, derived_virtual_selected_rows, n_clicks, clickData, value, children):
    style = {'display': 'none'}
    children = []
    all_pattern_sequences_ids = []
    seq_ids_per_pattern = []
    pattern_items = []
    if (value == 'tab-1' and derived_virtual_selected_rows is not None and len(derived_virtual_selected_rows) != 0) \
            or (value == 'tab-2' and clickData is not None and len(clickData['points']) != 0):
        if value == 'tab-1':
            selected_rule_ids = [row['rid'] for row in [rows[i] for i in derived_virtual_selected_rows]]
            selected_rules = [rule for rule in rules if str(rule.id) in selected_rule_ids]
            for rule in selected_rules:
                all_pattern_sequences_ids.extend(rule.seq_ids)
                seq_ids_per_pattern.append(rule.seq_ids)
                pattern_items.extend(rule.LHS)
                pattern_items.append(rule.RHS)

        else:
            selected_fis_ids = [point['customdata'] for point in clickData['points']]
            selected_fises = [fis for fis in freqitemsets if fis.id in selected_fis_ids]
            for fis in selected_fises:
                all_pattern_sequences_ids.extend(fis.seq_ids)
                seq_ids_per_pattern.append(fis.seq_ids)
                pattern_items.extend(fis.items)

        if n_clicks % 2 == 1:
            prfmnc = performance_detail_df if value == 'tab-1' else delta_performance_detail_df
            children.append(get_performance_table(prfmnc[prfmnc['Turnaround ID']
                                                  .isin(all_pattern_sequences_ids)], pattern_items,anonymous=True))
            style = {'display': 'block'}

        flights = flat_flight_tid[flat_flight_tid['Turnaround ID'].isin(all_pattern_sequences_ids)]

    else:
        flights = flat_flight_tid  # entire dataset
        seq_ids_per_pattern = tids_per_rule if value == 'tab-1' else tids_per_fis
    return get_sunburst(flights), get_heatmap(flights), get_weater_pc(seq_ids_per_pattern,
                                                                      weather_tid_df), style, children


app.run_server(debug=True)
